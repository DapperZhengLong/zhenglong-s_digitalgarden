---
{"dg-publish":true,"permalink":"/编程语言/c++/流程控制语句的识别/","dgPassFrontmatter":true}
---

流程控制语句的识别是逆向分析和还原高级代码的基础
# if语句
f语句是分支结构的重要组成部分。if语句的功能是先对运算条件进行比较，然后根据比较结果执行对应的语句块。if语句只能判断两种情况：“0”为假值，“非0”为真值。如果判断结果为真值，则进入语句块内执行语句；如果判断为假值，则跳过if语句块，继续运行程序的其他语句。需要注意的是，if语句转换的条件跳转指令与if语句的判断结果是相反的。
```c
int main(int argc, char* argv[]) {
	int b = 1;
	int c = 2;
	if (b == 3){
		int a = b + c;
	}
	return 0;
}
```

```
00791718  mov         dword ptr [ebp-8],1  
	int c = 2;
0079171F  mov         dword ptr [ebp-14h],2  
	if (b == 3){
00791726  cmp         dword ptr [ebp-8],3  
0079172A  jne         00791735
		int a = b + c;
0079172C  mov         eax,dword ptr [ebp-8]  
0079172F  add         eax,dword ptr [ebp-14h]  
00791732  mov         dword ptr [ebp-20h],eax 
```
`jne` 是 "jump not equal" 的缩写，跳转指令在两个操作数的值不相等（即零标志位 ZF 设置为0）时执行。在这段代码中，该指令跳转到内存地址为 `00791735` 的汇编指令。如果不跳转，说明 `b` 等于 3，则程序将继续按顺序执行接下来的指令。
`CMP`（Compare）指令是汇编语言中的一种用于比较两个操作数的指令。在 x86 架构中，这个指令主要用于设置相关的**标志位**，进而为后续的条件跳转（如 `JE`、`JNE`、`JG`、`JL` 等）或设置指令（如`SETLE`、`SETA`等）提供信息。

事实上，`CMP` 指令在内部执行了一个**减法（SUB）**操作（但不存储结果），然后根据操作结果设置处理器中的标志寄存器。以下是设置的一些主要标志位：

1. **零标志位（ZF）**：当两个操作数相等时设置为1，即减法结果为零。
2. **进位标志位（CF）**：当无符号数减法产生借位时设置为1。
3. **溢出标志位（OF）**：当有符号数减法产生溢出时设置为1。
4. **符号标志位（SF）**：当减法结果为负数时设置为1。
`CMP` 指令的基本格式如下：

```
cmp <操作数1>, <操作数2>
```
可以配合使用此类条件跳转指令：

- `JE` 或 `JZ`（在 ZF = 1 时跳转）
- `JNE` 或 `JNZ`（在 ZF = 0 时跳转）
- `JC`（在 CF = 1 时跳转）
- `JNC`（在 CF = 0 时跳转）
- `JO`（在 OF = 1 时跳转）
- `JNO`（在 OF = 0 时跳转）
- `JS`（在 SF = 1 时跳转）
- `JNS`（在 SF = 0 时跳转）
# switch语句
switch是比较常用的多分支结构，使用起来也非常方便
```c
switch (expression) {
    case constant1:
        // 代码块 1
        break;

    case constant2:
        // 代码块 2
        break;

    // 其他 case 语句...

    default:
        // 默认代码块（可选）
}
```

1. `expression`：在 `switch` 括号内的表达式，通常是一个变量或计算结果。它的结果将与 `case` constexpr 中的常量进行比较。
    
2. `case`：后跟一个常量值（或 constexpr），用于与表达式的结果进行比较。如果与 `switch` 中的 `expression` 相等，那么将执行相应 `case` 下的代码块。
    
3. `break`：用于停止 `switch` 语句的执行，并退出整个 `switch` 结构。如果缺少 `break`，那么程序将继续顺序执行下一个 `case`，直到遇到 `break` 或 `switch` 结构结束。
    
4. `default`：可选的代码块，当 `expression` 与其他所有 `case` 常量都不匹配时，将执行 `default` 代码块。如果不存在 `default` 分支，且所有 `case` 常量与 `expression` 都不相等，那么将不执行任何代码块。
```c
#include <stdio.h>

int main() {
	int input = 2; // 已定义的整数变量

	switch (input) {
	case 1:
		// 在这里执行 case 1 的代码
		input = 3;
		break;

	case 2:
		// 在这里执行 case 2 的代码
		input = 3;
		break;

	case 3:
		// 在这里执行 case 3 的代码
		input = 3;
		break;

	default:
		// 在这里执行 default 的代码
		input = 3;
	}

	return 0;
}
```

```
int input = 2; // 已定义的整数变量
005B3C58  mov         dword ptr [ebp-8],2  

	switch (input) {
005B3C5F  mov         eax,dword ptr [ebp-8]  
005B3C62  mov         dword ptr [ebp+FFFFFF30h],eax  
005B3C68  cmp         dword ptr [ebp+FFFFFF30h],1  
005B3C6F  je          005B3C85  
005B3C71  cmp         dword ptr [ebp+FFFFFF30h],2  
005B3C78  je          005B3C8E  
005B3C7A  cmp         dword ptr [ebp+FFFFFF30h],3  
005B3C81  je          005B3C97  
005B3C83  jmp         005B3CA0  
	case 1:
		// 在这里执行 case 1 的代码
		input = 3;
005B3C85  mov         dword ptr [ebp-8],3  
		break;
005B3C8C  jmp         005B3CA7  

	case 2:
		// 在这里执行 case 2 的代码
		input = 3;
005B3C8E  mov         dword ptr [ebp-8],3  
		break;
005B3C95  jmp         005B3CA7  

	case 3:
		// 在这里执行 case 3 的代码
		input = 3;
005B3C97  mov         dword ptr [ebp-8],3  
		break;
005B3C9E  jmp         005B3CA7  

	default:
		// 在这里执行 default 的代码
		input = 3;
005B3CA0  mov         dword ptr [ebp-8],3  
	}
```
# do、while、for
c++使用3种语法完成循环结构，分别为do、while、for。虽然它们的功能都是循环，但是每种语法有着不同的执行流程。
do循环：先执行循环体，后比较判断。
while循环：先比较判断，后执行循环体。
for循环：先初始化，再比较判断，最后执行循环体。
## do循环
`do-while` 循环是 C 语言中的一种循环结构，它至少执行一次循环体，然后根据给定条件决定是否继续循环。它的语法如下：
```c
do {
    // 循环体
} while (condition);
```
1. `循环体`：在 `do` 和 `while` 之间的代码块，至少会执行一次。
2. `condition`：在 `while` 括号内的条件表达式。如果条件为真（非零值），则继续执行循环体。如果条件为假（0），循环将结束。

这是一个简单的 `do-while` 循环示例，用于计算 1 到 10 之间整数的和：
```c
#include <stdio.h>

int main() {
    int sum = 0;
    int i = 1;

    do {
        sum += i; // 等效 sum = sum + i
        i++;
    } while (i <= 10);

    return 0;
}
```

```
00FF3C58  mov         dword ptr [ebp-8],0  
	int i = 1;
00FF3C5F  mov         dword ptr [ebp-14h],1  

	do {
		sum += i; // 等效 sum = sum + i
00FF3C66  mov         eax,dword ptr [ebp-8]  
00FF3C69  add         eax,dword ptr [ebp-14h]  
00FF3C6C  mov         dword ptr [ebp-8],eax  
		i++;
00FF3C6F  mov         eax,dword ptr [ebp-14h]  
00FF3C72  add         eax,1  
00FF3C75  mov         dword ptr [ebp-14h],eax  
	} while (i <= 10);
00FF3C78  cmp         dword ptr [ebp-14h],0Ah  
00FF3C7C  jle         00FF3C66 
```
`JLE`（Jump if Less or Equal）是 x86 汇编指令集中的一条条件跳转指令。`JLE` 会在符号数比较结果小于或等于时进行跳转。换句话说，如果满足条件，该指令会将执行流程跳转至目标地址。

具体来说，`JLE` 指令用于测试**零标志位（ZF）**和**符号标志位（SF）**与**溢出标志位（OF）**的关系。当以下条件之一满足时，`JLE` 指令会执行跳转：

1. ZF = 1：零标志位为1，此时操作数相等。
2. SF ≠ OF：符号标志位与溢出标志位不相等，此时左操作数小于右操作数。

`JLE` 指令的语法如下：

```
jle target_label
```
## while循环
while循环和do循环正好相反，在执行循环语句块之前，必须要进行条件判断，根据比较结果再选择是否执行循环语句块
```c
while (condition) {
    // 循环体
}
```
1. `condition`：在 `while` 括号内的条件表达式。如果条件为真（非零值），则执行循环体。如果条件为假（0），循环将结束。

这是一个简单的 `while` 循环示例，用于计算 1 到 10 之间所有整数的和：
```c
#include <stdio.h>

int main() {
	int sum = 0;
	int i = 1;

	while (i <= 10) {
		sum += i; // 等效 sum = sum + i
		i++;
	}

	return 0;
}
```

```
00733C58  mov         dword ptr [ebp-8],0  
	int i = 1;
00733C5F  mov         dword ptr [ebp-14h],1  

	while (i <= 10) {
00733C66  cmp         dword ptr [ebp-14h],0Ah  
00733C6A  jg          00733C80  
		sum += i; // 等效 sum = sum + i
00733C6C  mov         eax,dword ptr [ebp-8]  
00733C6F  add         eax,dword ptr [ebp-14h]  
00733C72  mov         dword ptr [ebp-8],eax  
		i++;
00733C75  mov         eax,dword ptr [ebp-14h]  
00733C78  add         eax,1  
00733C7B  mov         dword ptr [ebp-14h],eax  
	}
00733C7E  jmp         00733C66  
```
`JG` 会在符号数比较结果大于时进行跳转。换句话说，如果满足条件，该指令会将执行流程跳转至目标地址。

具体来说，`JG` 指令用于测试**零标志位（ZF）**和**符号标志位（SF）**与**溢出标志位（OF）**的关系。当以下条件满足时，`JG` 指令会执行跳转：

1. ZF = 0：零标志位为0，此时操作数不相等。
2. SF = OF：符号标志位与溢出标志位相等，此时左操作数大于右操作数。

`JG` 指令的语法如下：

```
jg target_label
```
## for循环
for循环是3种循环结构中最复杂的一种。for循环由赋初值、设置循环条件、设置循环步长3条语句组成。因为for循环更符合人类的思维方式，所以在循环结构中被使用的频率也最高
```c
for (initialization; condition; increment) {
    // 循环体
}
```
1. `initialization`：在 `for` 循环括号内的初始化表达式，通常用于初始化循环计数器（变量）。只在循环开始之前执行一次。
2. `condition`：条件表达式，如果条件为真（非零值），则执行循环体。如果条件为假（0），循环将结束。
3. `increment`：递增/递减表达式，用于在每次循环迭代完成后更新循环计数器。在每次执行循环体之后，这个表达式被执行。
以下是一个简单的 `for` 循环示例，用于计算 1 到 10 之间所有整数的和：
```c
#include <stdio.h>

int main() {
    int sum = 0;

    for (int i = 1; i <= 10; i++) {
        sum += i; // 相当于 sum = sum + i
    }

    return 0;
}
```

```
int sum = 0;
00EF3C58  mov         dword ptr [ebp-8],0  

	for (int i = 1; i <= 10; i++) {
00EF3C5F  mov         dword ptr [ebp-14h],1  
00EF3C66  jmp         00EF3C71  
00EF3C68  mov         eax,dword ptr [ebp-14h]  
00EF3C6B  add         eax,1  
00EF3C6E  mov         dword ptr [ebp-14h],eax  
00EF3C71  cmp         dword ptr [ebp-14h],0Ah  
00EF3C75  jg          00EF3C82  
		sum += i; // 相当于 sum = sum + i
00EF3C77  mov         eax,dword ptr [ebp-8]  
00EF3C7A  add         eax,dword ptr [ebp-14h]  
00EF3C7D  mov         dword ptr [ebp-8],eax  
	}
00EF3C80  jmp         00EF3C68  
```