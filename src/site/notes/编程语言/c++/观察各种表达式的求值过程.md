---
{"dg-publish":true,"permalink":"/编程语言/c++/观察各种表达式的求值过程/","dgPassFrontmatter":true}
---

# 算术运算和赋值
算术运算包括加法、减法、乘法和除法，也称为四则运算。
赋值运算类似于数学中的“等于”，是将一个内存空间中的数据传递到另一个内存空间。因为内存没有处理器那样的控制能力，所以各个内存单元之间是无法直接传递数据的，必须通过处理器访问并中转，以实现两个内存单元之间的数据传输。
在编译器中，通常算术运算与其他传递计算结果的代码组合后才能被视为一条有效的语句，如赋值运算或函数的参数传递。单独的算术运算虽然也可以编译通过，但是并不会生成代码。因为只进行计算而没有传递结果的运算不会对程序结果有任何影响，此时编译器会将其视为无效语句，等价于空语句，不会有任何编译处理
## 加法
加法运算对应的汇编指令为ADD。
```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[]) {

	int a = 1;
	int b = 2;
	int c = 0;
	c = a + b;
	return 0;
}
```

```
int a = 1;
007B1718  mov         dword ptr [ebp-8],1  
	int b = 2;
007B171F  mov         dword ptr [ebp-14h],2  
	int c = 0;
007B1726  mov         dword ptr [ebp-20h],0  
	c = a + b;
007B172D  mov         eax,dword ptr [ebp-8]  
007B1730  add         eax,dword ptr [ebp-14h]  
007B1733  mov         dword ptr [ebp-20h],eax  
```
## 减法
减法运算对应汇编指令SUB，虽然计算机只会做加法，但是可以通过补码转换将减法转变为加法的形式实现,比如-5
```
原码（正数5的二进制形式）: 0000 0000 0000 0000 0000 0000 0000 0101
反码（将原码取反）:        1111 1111 1111 1111 1111 1111 1111 1010
补码（反码加1）:            1111 1111 1111 1111 1111 1111 1111 1011

```

```
int a = 1;
00F11718  mov         dword ptr [ebp-8],1  
	int b = 2;
00F1171F  mov         dword ptr [ebp-14h],2  
	int c = 0;
00F11726  mov         dword ptr [ebp-20h],0  
	c = a - b;
00F1172D  mov         eax,dword ptr [ebp-8]  
00F11730  sub         eax,dword ptr [ebp-14h]  
00F11733  mov         dword ptr [ebp-20h],eax  
```
## 乘法
乘法运算对应的汇编指令分为有符号imul和无符号mul两种。由于乘法指令的执行周期较长，在编译过程中，编译器会先尝试将乘法转换成加法，或使用移位等周期较短的指令。当它们都不可转换时，才会使用乘法指令.
```c
int main(int argc, char* argv[]) {

	int a = 11;
	int b = 22;
	int c = 0;
	c = a * b;
	return 0;
}
```

```
00511718  mov         dword ptr [ebp-8],0Bh  
	int b = 22;
0051171F  mov         dword ptr [ebp-14h],16h  
	int c = 0;
00511726  mov         dword ptr [ebp-20h],0  
	c = a * b;
0051172D  mov         eax,dword ptr [ebp-8]  
00511730  imul        eax,dword ptr [ebp-14h]  
00511734  mov         dword ptr [ebp-20h],eax 
```
## 除法
### 除法计算约定
C++中的除法和数学中的除法不同，在C++中，除法运算不保留余数，有专门求取余数的运算（运算符为%），也称之为取模运算。对于整数除法，C++的规则是仅保留整数部分，小数部分完全舍弃。
对于除法而言，计算机面临着如何处理小数部分的问题。在数学意义上，7÷2=3.5，而对于计算机而言，整数除法的结果必须为整数。对于3.5这样的数值，计算机取整数部分的方式有如下几种。
a. 向下取整
b. 向上取整
c. 向零取整
在C语言和其他多数高级语言中，对整数除法规定为向零取整。也有人称这种取整方法为截断除法（truncate）。
```c
int main(int argc, char* argv[]) {

	int a = 144;
	int b = 255;
	int c = 0;
	c = a / b;
	return 0;
}

```

```
	int a = 144;
005A1718  mov         dword ptr [ebp-8],90h  
	int b = 255;
005A171F  mov         dword ptr [ebp-14h],0FFh  
	int c = 0;
005A1726  mov         dword ptr [ebp-20h],0  
	c = a / b;
005A172D  mov         eax,dword ptr [ebp-8]  
005A1730  cdq  
005A1731  idiv        eax,dword ptr [ebp-14h]  
005A1734  mov         dword ptr [ebp-20h],eax 
```
当使用 `cdq` 指令时，EDX 和 EAX 寄存器的组合将形成一个 64 位的有符号数值。在这种情况下，EDX 寄存器中存储的是高 32 位，而 EAX 寄存器中存储的是低 32 位。举个例子，如果 EAX 寄存器中的数值是 `0x12345678`，执行 `cdq` 指令后，会进行符号扩展。若 EAX 中的值为正数（最高位为 0），则 EDX 寄存器将设置为 `0x00000000`；这样，在执行除法操作时，EDX 和 EAX 寄存器组合成的 64 位数值就是 `0x0000000012345678`（如果是正数）。如果 EAX 寄存器中的数值是 `-12345678`，那么它实际上会以补码的形式存储为 `0xEDCBA988`。执行 `cdq` 指令后，由于 EAX 中的值是负数（最高位为 1），EDX 寄存器中的值将设置为 `0xFFFFFFFF`。所以，在执行除法操作时，EDX 和 EAX 寄存器组合成的 64 位数值就是 `0xFFFFFFFFEDCBA988`，对于 64 位有符号整数，`0xFFFFFFFFEDCBA988` 的十进制值确实表示 `-12345678`。
### 余数计算
![image.png](https://raw.githubusercontent.com/DapperZhengLong/imgroom/main/obsidian/20240815014831.png)
```c
	int a = 144;
	int b = 255;
	int c = 0;
	c = a % b;
	return 0;
```

```
0031171F  mov         dword ptr [ebp-14h],0FFh  
	int c = 0;
00311726  mov         dword ptr [ebp-20h],0  
	c = a % b;
0031172D  mov         eax,dword ptr [ebp-8]  
00311730  cdq  
00311731  idiv        eax,dword ptr [ebp-14h]  
00311734  mov         dword ptr [ebp-20h],edx 
```
在执行 `idiv` 指令进行整数除法后，商（Quotient）存储在 EAX 寄存器，余数（Remainder）存储在 EDX 寄存器。
## 溢出
占据4字节32位内存空间的数据经过运算后，得到的结果超出存储空间的大小，就会产生溢出现象。
比如0xFFFFFFFF加2
![image.png](https://raw.githubusercontent.com/DapperZhengLong/imgroom/main/obsidian/20240815131215.png)
对于二进制加法运算，我们使用进位标志位（Carry Flag，CF）来检查无符号整数操作的溢出，而使用溢出标志位（Overflow Flag，OF）来检查有符号整数操作的溢出。这两种标志位分别用于检测不同类型整数的溢出情况，确保我们能够根据不同类型整数运算的需求来处理运算过程中的异常情况。

1. 无符号整数：当我们对无符号整数进行加法运算时，不需要关心符号问题，只需要进行基本的二进制加法。此时，使用 CF 标志位来检测是否进位是正确的。我们可以根据预期和实际结果之间的差异来确定进位的值，从而得出正确的结果。
    
2. 有符号整数：对于有符号整数加法，我们需要检查运算是否导致溢出。例如，加法操作可能导致正溢出（两个正数相加得到负数）或负溢出（两个负数相加得到正数）。为了检测这种溢出情况，我们需要使用 OF 标志位。然而，简单地将 OF 的值加到计算结果中，并不能保证我们得到正确的结果。OF 只能帮助我们检测运算过程中是否发生了溢出，而并不能提供足够的信息来修正溢出造成的错误。
让我们以一个 32 位有符号整数加法溢出的例子进行说明。
```
A = 2147483647 (0x7FFFFFFF)
B = 1000       (0x000003E8)

  01111111 11111111 11111111 11111111 (A=2147483647, 0x7FFFFFFF)
+ 00000000 00000000 00000011 11101000 (B=1000, 0x000003E8)
---------------------------------------
1|10000000 00000000 00000000 00001000 (0x80000008)
```
我们忽略了最高位的进位，得到的结果是 `10000000 00000000 00000000 00001000`。这是一个补码表示的负数（最高位为 1），我们期望得到的结果实际上是一个正数。因此，这个加法操作导致了正溢出。执行这个加法操作后，溢出标志位（Overflow Flag, OF）会被设置为 1，以表示发生了溢出。在实际操作中，我们不会直接把 OF 的值加到计算结果上。OF 只是一个用于指示溢出情况的标志位，而不是一个可以直接与计算结果相加的数值。
我们演示将 OF 值（1）加到计算结果 `0x80000008`：
```
0x80000008 + 0x1 = 0x80000009
```

将十六进制数 `0x80000009` 转换为十进制表示：

```
10000000 00000000 00000000 00001001 (0x80000009)
```

此二进制序列表示的有符号整数为：`-2147483647`。

需要注意的是，这个结果与我们原先期望的正确结果（`2147483647 + 1000 = 2147484647`）相去甚远
## 自增和自减
自增（increment）和自减（decrement）操作允许您简洁地将变量的值增加或减少 1。这些操作可以通过使用自增运算符 `++` 和自减运算符 `--` 来实现
1. 自增操作：

```c
int count = 0;
count++; // 等价于 count = count + 1;
```

```
00D21725  mov         ecx,dword ptr [ebp-8]  
00D21728  add         ecx,1  
00D2172B  mov         dword ptr [ebp-8],ecx
```

2. 自减操作：

```c
int count = 5;
count--; // 等价于 count = count - 1;
```
自增和自减操作有两种模式：前缀模式和后缀模式。

- 前缀模式 (`++count` 或 `--count`)：首先执行自增/自减操作，然后返回更新后的值。
    
- 后缀模式 (`count++` 或 `count--`)：首先返回当前值，然后执行自增/自减操作。
# 关系运算和逻辑运算
关系运算用于判断两者之间的关系，如等于、不等于、大于。
逻辑运算用于判定两个逻辑值之间的依赖关系，如或、与、非，对应的符号有“||”“&&”“！”
## 或运算
比较运算符||左右的语句的结果，如果有一个值为真，则返回真值；如果都为假，则返回假值。
## 与运算
比较运算符&&左右的语句的结果，如果有一个值为假，则返回假值；如果都为真值，则返回真值。
## 非运算
改变运算符！后面语句的真假结果，如果该语句的结果为真值，则返回假值；如果为假值，则返回真值。
### 关系运算和条件跳转的对应
| 指令        | 描述                   | 条件                               |
| --------- | -------------------- | -------------------------------- |
| JE / JZ   | 如果相等则跳转 / 如果为零则跳转    | 零标志位（ZF）=1                       |
| JNE / JNZ | 如果不相等则跳转 / 如果不为零则跳转  | 零标志位（ZF）=0                       |
| JA / JNBE | 如果大于则跳转 / 如果不小于等于则跳转 | 进位标志位（CF）=0 & 零标志位（ZF）=0         |
| JAE / JNB | 如果大于等于则跳转 / 如果不小于则跳转 | 进位标志位（CF）=0                      |
| JB / JC   | 如果小于则跳转 / 如果有进位则跳转   | 进位标志位（CF）=1                      |
| JBE / JNA | 如果小于等于则跳转 / 如果不大于则跳转 | 进位标志位（CF）=1 或 零标志位（ZF）=1         |
| JG / JNLE | 如果大于则跳转 / 如果不小于等于则跳转 | 符号标志位（SF）=溢出标志位（OF）& 零标志位（ZF）=0  |
| JGE / JNL | 如果大于等于则跳转 / 如果不小于则跳转 | 符号标志位（SF）=溢出标志位（OF）              |
| JL / JNGE | 如果小于则跳转 / 如果不大于等于则跳转 | 符号标志位（SF）≠溢出标志位（OF）              |
| JLE / JNG | 如果小于等于则跳转 / 如果不大于则跳转 | 符号标志位（SF）≠溢出标志位（OF） 或 零标志位（ZF）=1 |
`JE`（Jump if Equal）或者 `JZ`（Jump if Zero）指令是当零标志位（ZF）为1时跳转到指定的内存地址。这表示上一个比较指令（如 `cmp`）的操作数相等，或者上一个算术指令（如 `sub`）的结果为零。
以 x86 架构为例，下表显示了 EFLAGS 寄存器中几个关键标志位的位置位。

| 位（从0开始） | 标志位 | 含义                                        |
| ------- | --- | ----------------------------------------- |
| 0       | CF  | 进位标志（Carry Flag）                          |
| 2       | PF  | 奇偶标志（Parity Flag，此标志位不常用于条件跳转）            |
| 4       | AF  | 辅助进位标志（Auxiliary Carry Flag，此标志位不常用于条件跳转） |
| 6       | ZF  | 零标志（Zero Flag）                            |
| 7       | SF  | 符号标志（Sign Flag）                           |
| 11      | OF  | 溢出标志（Overflow Flag）                       |

### 表达式短路
在 C 语言中，表达式短路是指逻辑与（`&&`）和逻辑或（`||`）操作符的一种特性。在遇到这两个操作符时，如果第一个操作数已经足以确定整个表达式的结果，那么编译器会在处理第一个操作数后终止表达式的计算。这可以提高计算效率，避免执行不必要的操作。

考虑以下两种短路特性：

1. 逻辑与（`&&`）：如果一个表达式中使用了逻辑与操作符，那么当第一个操作数的值为假（`0`）时，整个表达式的结果将为假，此时编译器将忽略后续的操作数。
2. 逻辑或（`||`）：类似地，在一个包含逻辑或操作符的表达式中，如果第一个操作数的值为真（非零），整个表达式的结果将为真，后续操作数将被忽略。
### 条件表达式
条件表达式也称为三目运算，根据比较表达式1得到的结果进行选择。如果是真值，执行表达式2；如果是假值，执行表达式3，语句的构成如下。
表达式1？表达式2：表达式3
条件表达式也属于表达式的一种，所以表达式1、表达式2、表达式3都可以套用到条件表达式中。套用条件表达式后，执行顺序依然是由左向右，自内向外。
# 位运算
1. 左移运算符（`<<`）：将操作数的二进制位向左移动指定的位数，左侧舍弃，右侧用零填充。

```c
#include <stdio.h>

int main() {
    int num = 5; // 二进制：0000 0101
    int shift = num << 2; // 二进制：0001 0100，十进制：20

    printf("num = %d, shift = %d\n", num, shift);
    return 0;
}
```

```
	int num = 5; // 二进制：0000 0101
007F1DD8  mov         dword ptr [ebp-8],5  
	int shift = num << 2; // 二进制：0001 0100，十进制：20
007F1DDF  mov         eax,dword ptr [ebp-8]  
007F1DE2  shl         eax,2  
007F1DE5  mov         dword ptr [ebp-14h],eax 
```

2. 右移运算符（`>>`）：将操作数的二进制位向右移动指定的位数，右侧舍弃，左侧用最高位的值填充。

```c
#include <stdio.h>

int main() {
    int num = 20; // 二进制：0001 0100
    int shift = num >> 2; // 二进制：0000 0101，十进制：5

    printf("num = %d, shift = %d\n", num, shift);
    return 0;
}
```

3. 位或运算符（`|`）：对操作数的每一位进行或运算。

```c
#include <stdio.h>

int main() {
    int a = 12; // 二进制：1100
    int b = 7;  // 二进制：0111
    int result = a | b; // 二进制：1111，十进制：15

    printf("result = %d\n", result);
    return 0;
}
```

4. 位与运算符（`&`）：对操作数的每一位进行与运算。

```c
#include <stdio.h>

int main() {
    int a = 12; // 二进制：1100
    int b = 7;  // 二进制：0111
    int result = a & b; // 二进制：0100，十进制：4

    printf("result = %d\n", result);
    return 0;
}
```

5. 异或运算符（`^`）：对操作数的每一位进行异或运算。

```c
#include <stdio.h>

int main() {
    int a = 12; // 二进制：1100
    int b = 7;  // 二进制：0111
    int result = a ^ b; // 二进制：1011，十进制：11

    printf("result = %d\n", result);
    return 0;
}
```
两个位相等时异或结果为0，否则为1。以下是异或运算的真值表：

| A   | B   | A ^ B |
| --- | --- | ----- |
| 0   | 0   | 0     |
| 0   | 1   | 1     |
| 1   | 0   | 1     |
| 1   | 1   | 0     |
```
	int a = 12; // 二进制：1100
00071DD8  mov         dword ptr [ebp-8],0Ch  
	int b = 7;  // 二进制：0111
00071DDF  mov         dword ptr [ebp-14h],7  
	int result = a ^ b; // 二进制：1011，十进制：11
00071DE6  mov         eax,dword ptr [ebp-8]  
00071DE9  xor         eax,dword ptr [ebp-14h]  
00071DEC  mov         dword ptr [ebp-20h],eax  
```
6. 取反运算符（`~`）：对操作数的每一位取反。

```c
#include <stdio.h>

int main() {
    int num = 5; // 二进制：0000...0101（32 位有符号整数假设）
    int result = ~num; // 二进制：1111...1010，十进制：-6（补码）

    printf("result = %d\n", result);
    return 0;
}
```
在程序算法中大量使用位运算，如不可逆算法MD5，就是通过大量位运算完成的。如何使一个数不可逆转呢？利用位运算就可以达到这个目的，如x & 0结果为0，而根据结果，是不可以逆推x的值的。由于大多数位运算会导致数据信息的丢失（取反~和异或^可以反推），因此，在知道原算法的前提下，使用逆转算法是无法计算出原数据的。在算术运算中，编译器会将各种运算转换成位运算，因此掌握位运算对于学会算法识别是一件非常重要的事